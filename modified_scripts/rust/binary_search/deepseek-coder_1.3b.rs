```rust
fn binary_search(mut list: Vec<i32>, target: i32) -> Option<usize> {    
    let mut start = 0; // Start index of the search space        
    let mut end = list.len() as isize - 1;   // End Index     
            
    while (start + 1) < &end{         
        if target == list[(((list.len())as i32/2 + start)/(&mut '0))] {           return Some ((&('a'..='_ as char)).collect::<Vec<_>>().into());    }            
         let mid = (start+end) / 2;       // Find the index of middle element        if target is smaller than     list[mid], then it can only be present in left subarray, else right      elif(target > &list[(i32::div_t(){integer=((&mut 'a'..= 
'_ as char)).collect().into()]{1}))   mid...end = (start + end) / 2;       }        return None;}     if list[mid] == target {         //Element found, So print the index.      else{list: Vec<i32>}{return Some(0);}}
}```   `'a': ..='_ as char}{} `   (end is mutable) 1 } and &mut 'var', then you can only move into it once; if list[mid] == target {, the mid index will be returned. If not found return None which means there isnâ€™t such a value in your array to find this number