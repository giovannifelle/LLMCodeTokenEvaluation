```c++
int matrix_multiplication(const int* A, const size_t nA, const int m1a, // input sizes and dimensions of matrices are provided here in order (rows from the first Matrix to be multiplied by columns form second) 
                         const int *B, const size_t m2b,          // B is a matrix that will multiply A. It has as many rows as there's elements for input array 'A', and one column per element in Array "a".  
                         int* C){                                           // The result of the multiplication should be stored here (C[m1a][n2b])  since matrix_multiplication(B, n2b) is called. It has m1a rows for input array 'A', and one column per element in Array "b".
    int sum = 0; // Initialize the variable to hold each cell of result C[i*m2+j]  (sum = A[i * m + j]) multiplied by B(k, n) which is equal at k=n. It's initialized in a loop from i and then stored back into matrix_multiplication().
    for(int i = 0; i < nA ; ++i){  // Loop over rows of A   (for each element on the first array multiply it with all elements on second)  This is done using modifying pointers. Therefore, a new loop variable 'j' should be added to prevent confusion about indices when reading from and writing into C in matrix_multiplication().
        for(int j = 0; j < m2b ; ++j){   // Loop over columns of B (for each element on the second array multiply it with all elements off first)  This is also done using modifying pointers. A new loop variable 'k' should be added to prevent confusion about indices when reading from and writing into C in matrix_multiplication().
            for(int k = 0; k < m1a ; ++k){ // Loop over rows of result (for each cell multiply elements on input matrices)  This is done using modifying pointers. A new loop variable 'l' should be added to prevent confusion about indices when reading from and writing into C in matrix