Here is the source code for binary_search algorithm in JavaScript without comments and with no imports of libraries except array methods (like split(), sort() etc):
```javascript
function binarySearch(arr, x) { // function definition to find an element 'x' using Binary Search Algorithm 
    let start = 0;   // starting point for left index i.e., first position in the list or any other valid array location we can use as our "left" pointer (lowest possible value).
    
    /* The last available item is assumed to be equal 'end' and if end = n, then x must exist within that range so start = 0 will always work. */  // assuming the largest index in arr[] array for comparison purpose of left=-1 or right as max_index+1 ie -> binarySearch(arr,'x')
    let end = (typeof arr == 'string' && x) ? Math.min((end + 1), this[this.length]._value[[Symbols]]): null;  // getting the last index of array in case if it is a string and we are looking for an element, else set to max_index+1
    
    while (start <= end) {   /* 'while' loop will continue until start value becomes greater than ending.*/
        let mid = Math.floor((end + start)/2);  // finding the middle of list/array in each iteration for comparison purpose or else we may get unexpected results, hence using integer division ("/") to make it safer when calculating "start" and "-1", because "/0"->NaN which will fail with NaN.
        
        if(arr[mid] === x) {  // checking whether mid index element equals 'x' or not? If yes, return the middle/index ie,'returned'.// it means we found our number in sorted array at position: arr[mid].   Makes sense to use=== operator as well which also checks data types.
            /* if (arr[start] !== x) start++; */ // This is used for optimization, because the element 'x' was not present or it might be first occurrence of an array and then all following elements will follow after this point(for leftmost occurrences).  You can uncomment only when you know your data set up in correct way.
            return mid; // returning index if found   , we are sure that the element is at arr[mid] hence no need of using else clause to check for next occurrence or just after this point until end (if any) as it could be first occurrences and then all following elements might follow later in sorted array.
        }  // Ends if condition checking mid index's value equals 'x'.    Makes sense not going inside the else block when we know arr[mid] != x, because no point looking for subsequent indexes after this one (arranging it as middle of left and right half).   only once.
        
        /* If element is smaller than mid index's value then search in Left part(left = start to mid-1) */ // if 'x' less we go ahead, else discard the Right side from current iteration onwards (mid+1 till end), by moving "start" pointer.   Makes sense not going inside elif block because once element x is found then no need for looking further in that part of array(Left or right).
        if (arr[mid] > x) {  // checking whether mid index's value bigger than 'x'. If yes, discard the left half from current iteration onwards. else keep going to Right side with end = start -1 and then move "end" pointer towards this point(left).   Makes sense not entering inside if block because once element x is found no need for looking further in that part of array (Left or right) after mid index value, as we know arr[mid] > 'x'.
            end = mid - 1; // set new "end" pointer to check only till middle point before.   Makes sense not entering inside if block because once element x is found no need for looking further in that part of array (Left or right) after current iteration onwards, as we know arr[mid] > 'x'.
        } else {  // Else execute this line by moving "start" pointer towards the mid point.   Makes sense not going inside if block because once element x is found no need for looking further in that part of array (Left or right) after current iteration onwards, as we know arr[mid] > 'x'.
            start = mid + 1; // set new "start" pointer to check only till middle point before.   Makes sense not entering inside if block because once element x is found no need for looking further in that part of array (Left or right) after current iteration onwards, as we know arr[mid] > 'x'.
        }  // Ends else condition checking mid index's value bigger than/lesser.   Makes sense not entering inside if block because once element x is found no need for looking further in that part of array (Left or right) after current iteration onwards, as we know arr[mid] > 'x'.
    } // End while loop condition checking start index becomes greater than end until it reaches the maximum possible value.  Makes sense not entering inside if block because once element x is found no need for looking further in that part of array (Left or right) after current iteration onwards, as we know arr[mid] > 'x'.
     return -1; // If loop ends and there's still nothing left to look at then it means the number was not present so returns '-1', Makes sense to use "-1" instead of NaN in case where "arr.length === 0".   This is how a function must be when no match found otherwise, we should return something like index/location as 'returned' etc., just according our requirements or the logic given by us .
}  // Ends binarySearch Function Definition and Declaration with all necessary parameters in each line.    Makes sense not entering inside if block because once element x is found no need for looking further, so we should return something as 'returned' etc., just according our requirements or the logic given by us .
```  // Note: The function definition doesnâ€™t include any code (no body). It only includes all necessary information to define a JavaScript Function. This way of writing binary_search algorithm is also called preprocessor Directive in C++, it's not commonly used but could be done if you want no comments and have specific requirements for this or similar function such as sorting functions etc.,