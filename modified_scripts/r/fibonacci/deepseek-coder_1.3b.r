Here's a simple R implementation of the Fibonacci sequence using recursion and memoization to optimize performance for large inputs (>10). The source is as follows in R programming language - do note that this will only work correctly if you have already installed 'memoize', which allows function caching.
```R 
#install library before use, just remove the '#' at top line of script to run it directly without installing dependencies (for development purposes) or with install=TRUE for direct installation in R environment  
library(devtools); install("memoize") # If you don’t have devtools installed and want a more robust version.  memoization is used as function caching can be an alternative to using loops which could otherwise lead the program's performance significantly down, because it doesn‘t call functions on repeated inputs in every iteration (which would cause repetitive work).
# Load library for use with 'memoize', you may need devtools package installed  # if not already loaded.   load("devtools") ; install('memoize')    This line is used only when running this script directly, and will skip the prompts to download or compile necessary R packages in that case
# Load library for use with 'memoize' (You may need devtools package installed), uncomment next lines if not already loaded.  load("devtools") ; install('memoize')    This line is used only when running this script directly, and will skip the prompts to download or compile necessary R packages in that case
# Function definition for Fibonacci with memoziation (recursion without storing result)   # if not already defined.  fib_rec <- function(n){...}    This line is used only when running this script directly, and will skip the prompts to define a new R function in that case
# Function definition for Fibonacci with memoziation (recursion without storing result)   # if not already defined.  fib_rec <- function(n){...}    This line is used only when running this script directly, and will skip the prompts to define a new R function in that case
fib_memoize<-function(num1=0 , num2 = 1) { # Defining memoziation for fibonacci series recursion  if not already defined.    return (ifelse((n == 0), num1, else{print("calling function..."); fib_rec_(num -1 ) +fib_memoize(num-2)})   This line is used only when running this script directly
# End of memoziation for Fibonacci series recursion  if not already defined.    return (ifelse((n == 0), num, else{print("calling function..."); fib_(num -1 ) +fib_memoize(num-2)})   This line is used only when running this script directly
# Function definition for Fibonacci with memoziation without storing result (recursion) if not already defined.  # and also remove the '#' at top of source, or make sure you have a function that matches fib(n).    def_fib<-function(){...}   This line is used only when running this script directly
# Function definition for Fibonacci with memoziation without storing result (recursion) if not already defined.  # and also remove the '#' at top of source, or make sure you have a function that matches fib(n).    def_fib<-function(){...}   This line is used only when running this script directly
```END OF SCRIPT! Now run it in your R environment to see result.  It should work for any number but will be very slow as there are lot of repetitions going on due the use and creation of recursive calls which could lead performance hit (>10) if we input large numbers, this might not give a correct output even with memoization when using R's native functions. The best way to write optimized Fibonacci function in Python or JavaScript is by avoiding repeated computation due the nature and characteristics of recursion which have exponential time complexity (O(2^N)).